#include<bits/stdc++.h>
using namespace std;
#define mod 100999
#define MAX 2000

int t, n;
// D[i][j] = 1 ~ j 사이의 수들의 합으로 i를 만드는 방법의 수 
int D[2005][2005];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> t;

    for(int i = 0; i <= MAX; i++)
        D[0][i] = 1;

    for(int i = 1; i <= MAX; i++){
        for(int j = 1; j <= MAX; j++){
                // j를 사용하지 않고 i를 만드는 경우
                // j가 i를 넘어갈 경우 i보다 큰 수로 i를 만들 수 없기때문에 방법의 수가 늘어나지 않는다.
				D[i][j] = D[i][j - 1];
				if(i >= j)
                    // 미지수 x 에 j를 더해서 i가 되는 경우 = D[i - j]
                    // 이 때, j를 사용하지 않은 지점 = D[i - j][j - 1]
                    // (1부터 j - 1 까지의 숫자만 사용하였기 때문에)
					D[i][j] += D[i - j][j - 1] % mod;
        }
    }
    // D[10][0] = 0
    // D[10][1] = D[10 - 1][1 - 1] = D[9][0] = 0
    // D[10][2] = D[10][1] + D[10 - 2][2 - 1] = 0 + D[8][1] = 0
    // D[10][3] = D[10][2] + D[10 - 3][3 - 1] = 0 + D[7][2] = 0
    // D[10][4] = D[10][3] + D[10 - 4][4 - 1] = 0 + D[6][3] = 1
    // D[10][5] = D[10][4] + D[10 - 5][5 - 1] = 1 + D[5][4] = 3
    // D[10][6] = D[10][5] + D[10 - 6][6 - 1] = 3 + D[4][5] = 5
    // D[10][7] = D[10][6] + D[10 - 7][7 - 1] = 5 + D[3][6] = 7
    // D[10][8] = D[10][7] + D[10 - 8][8 - 1] = 7 + D[2][7] = 8
    // D[10][9] = D[10][8] + D[10 - 9][9 - 1] = 8 + D[1][8] = 9
    // D[10][10] = D[10][9] + D[10 - 10][10 - 1] = 9 + D[0][9] = 10

    while(t--){
        cin >> n;
        cout << D[n][n] % mod << '\n';
    }
}