#include<bits/stdc++.h>
using namespace std;

int t[20];
int p[20];
int D[20]; // i번째 일에 상담을 시작했을 때 얻을 수 있는 최대 수익

int main(){
    ios::sync_with_stdio(0);
    cin.tie();

    int n;
    cin >> n;

    for(int i = 1; i <= n; i++)
        cin >> t[i] >> p[i];

    for (int i = n; i >= 1; i--) {
        // i번째 일에 상담을 할 수 있을 경우
        // == i일 + 상담에 걸리는 기간 t[i]가 퇴사일인 n + 1을 넘지 않는 경우
        if (i + t[i] <= n + 1) {
            // i번째 일에 상담을 했을 때와 상담을 하지 않았을 때 얻을 수 있는 수익 중 최대 수익을 취함
            D[i] = max(D[i + t[i]] + p[i], D[i + 1]);
        }
        else D[i] = D[i + 1];
    }
/* 예제 입력 1에서 테이블이 채워지는 순서
문제 설명에서는 1, 4, 5일에 있는 상담을 하는 것이 최대 이익이라고 하였지만
답이 2개임 {1, 4, 5}와 {3, 4, 5}
역순으로 테이블을 채우면 3, 4, 5라는 답을 찾게 된다.
i = 7
7 + 2가 7 + 1 보다 크기때문에
D[7] = D[8]
D : 0 0 0 0 0 0 0 0

i = 6
6 + 4가 7 + 1 보다 크기때문에
D[6] = D[7]
D : 0 0 0 0 0 0 0 0

i = 5
5 + 2가 7 + 1 보다 작기때문에
D[5] = max(D[5 + 2] + 15, D[5 + 1]);
D : 0 0 0 0 15 0 0 0

i = 4
4 + 1이 7 + 1 보다 작기때문에
D[4] = max(D[4 + 1] + 20, D[4 + 1]);
D : 0 0 0 35 15 0 0 0

i = 3
3 + 1이 7 + 1 보다 작기때문에
D[3] = max(D[3 + 1] + 10, D[3 + 1]);
D : 0 0 45 35 15 0 0 0

i = 2
2 + 5이 7 + 1 보다 작기때문에
D[2] = max(D[2 + 5] + 20, D[2 + 1]);
하지만 D[2 + 5] + 20은 20이고 D[2 + 1]은 45이기때문에 45로 갱신됨
D : 0 0 45 35 15 0 0 0

i = 1
1 + 3이 7 + 1 보다 작기때문에
D[1] = max(D[1 + 3] + 10, D[1 + 1]);
※ D[1 + 3] + 10 == D[1 + 1];
D : 0 45 45 35 15 0 0 0
*/
  cout << *max_element(D, D + n + 1);
}